/* tslint:disable */
/* eslint-disable */
/**
 * Mario Kart Wii Players\' Page API
 * The brains of the Mario Kart Wii Players\' Page.
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Player,
  PlayerBasic,
  Region,
  Score,
  ScoreWithPlayer,
  StandardLevel,
  Track,
  TrackCup,
} from '../models/index';
import {
    PlayerFromJSON,
    PlayerToJSON,
    PlayerBasicFromJSON,
    PlayerBasicToJSON,
    RegionFromJSON,
    RegionToJSON,
    ScoreFromJSON,
    ScoreToJSON,
    ScoreWithPlayerFromJSON,
    ScoreWithPlayerToJSON,
    StandardLevelFromJSON,
    StandardLevelToJSON,
    TrackFromJSON,
    TrackToJSON,
    TrackCupFromJSON,
    TrackCupToJSON,
} from '../models/index';

export interface TimetrialsPlayersRetrieveRequest {
    id: number;
}

export interface TimetrialsPlayersScoresListRequest {
    id: number;
    category?: TimetrialsPlayersScoresListCategoryEnum;
}

export interface TimetrialsRecordsListRequest {
    category?: TimetrialsRecordsListCategoryEnum;
}

export interface TimetrialsStandardsListRequest {
    isLegacy?: boolean;
}

export interface TimetrialsTracksScoresListRequest {
    id: number;
    category?: TimetrialsTracksScoresListCategoryEnum;
    isLap?: boolean;
}

/**
 * 
 */
export class TimetrialsApi extends runtime.BaseAPI {

    /**
     */
    async timetrialsCupsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TrackCup>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/cups/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TrackCupFromJSON));
    }

    /**
     */
    async timetrialsCupsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TrackCup>> {
        const response = await this.timetrialsCupsListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsPlayersListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<PlayerBasic>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/players/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PlayerBasicFromJSON));
    }

    /**
     */
    async timetrialsPlayersList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<PlayerBasic>> {
        const response = await this.timetrialsPlayersListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsPlayersRetrieveRaw(requestParameters: TimetrialsPlayersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Player>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling timetrialsPlayersRetrieve().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/players/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlayerFromJSON(jsonValue));
    }

    /**
     */
    async timetrialsPlayersRetrieve(requestParameters: TimetrialsPlayersRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Player> {
        const response = await this.timetrialsPlayersRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsPlayersScoresListRaw(requestParameters: TimetrialsPlayersScoresListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Score>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling timetrialsPlayersScoresList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/players/{id}/scores/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ScoreFromJSON));
    }

    /**
     */
    async timetrialsPlayersScoresList(requestParameters: TimetrialsPlayersScoresListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Score>> {
        const response = await this.timetrialsPlayersScoresListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsRecordsListRaw(requestParameters: TimetrialsRecordsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ScoreWithPlayer>>> {
        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/records/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ScoreWithPlayerFromJSON));
    }

    /**
     */
    async timetrialsRecordsList(requestParameters: TimetrialsRecordsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ScoreWithPlayer>> {
        const response = await this.timetrialsRecordsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsRegionsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Region>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/regions/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RegionFromJSON));
    }

    /**
     */
    async timetrialsRegionsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Region>> {
        const response = await this.timetrialsRegionsListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsStandardsListRaw(requestParameters: TimetrialsStandardsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<StandardLevel>>> {
        const queryParameters: any = {};

        if (requestParameters['isLegacy'] != null) {
            queryParameters['is_legacy'] = requestParameters['isLegacy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/standards/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StandardLevelFromJSON));
    }

    /**
     */
    async timetrialsStandardsList(requestParameters: TimetrialsStandardsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<StandardLevel>> {
        const response = await this.timetrialsStandardsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsTracksListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Track>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/tracks/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TrackFromJSON));
    }

    /**
     */
    async timetrialsTracksList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Track>> {
        const response = await this.timetrialsTracksListRaw(initOverrides);
        return await response.value();
    }

    /**
     */
    async timetrialsTracksScoresListRaw(requestParameters: TimetrialsTracksScoresListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ScoreWithPlayer>>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling timetrialsTracksScoresList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['isLap'] != null) {
            queryParameters['is_lap'] = requestParameters['isLap'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/timetrials/tracks/{id}/scores/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters['id']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ScoreWithPlayerFromJSON));
    }

    /**
     */
    async timetrialsTracksScoresList(requestParameters: TimetrialsTracksScoresListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ScoreWithPlayer>> {
        const response = await this.timetrialsTracksScoresListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const TimetrialsPlayersScoresListCategoryEnum = {
    NonShortcut: 'nonsc',
    Shortcut: 'sc',
    Unrestricted: 'unres'
} as const;
export type TimetrialsPlayersScoresListCategoryEnum = typeof TimetrialsPlayersScoresListCategoryEnum[keyof typeof TimetrialsPlayersScoresListCategoryEnum];
/**
 * @export
 */
export const TimetrialsRecordsListCategoryEnum = {
    NonShortcut: 'nonsc',
    Shortcut: 'sc',
    Unrestricted: 'unres'
} as const;
export type TimetrialsRecordsListCategoryEnum = typeof TimetrialsRecordsListCategoryEnum[keyof typeof TimetrialsRecordsListCategoryEnum];
/**
 * @export
 */
export const TimetrialsTracksScoresListCategoryEnum = {
    NonShortcut: 'nonsc',
    Shortcut: 'sc',
    Unrestricted: 'unres'
} as const;
export type TimetrialsTracksScoresListCategoryEnum = typeof TimetrialsTracksScoresListCategoryEnum[keyof typeof TimetrialsTracksScoresListCategoryEnum];
